(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{321:function(e,v,_){"use strict";_.r(v);var c=_(14),o=Object(c.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"react16"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#react16"}},[e._v("#")]),e._v(" React16")]),e._v(" "),v("h2",{attrs:{id:"架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#架构"}},[e._v("#")]),e._v(" 架构")]),e._v(" "),v("p",[e._v("React16架构分为三层：")]),e._v(" "),v("ul",[v("li",[e._v("Scheduler（调度器）- 调度任务的优先级，高优先级优先进入"),v("code",[e._v("Reconciler")])]),e._v(" "),v("li",[e._v("Reconciler（协调器）- 负责找出变化的组件")]),e._v(" "),v("li",[e._v("Renderer（渲染器）- 负责将变化的组件渲染到页面上")])]),e._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),v("p",[e._v("相比较于15，增加了Scheduler调度任务")])]),e._v(" "),v("h3",{attrs:{id:"scheduler-调度器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#scheduler-调度器"}},[e._v("#")]),e._v(" Scheduler（调度器）")]),e._v(" "),v("p",[e._v("如果需要实现异步，那么就需要知道浏览器是否有剩余时间，在浏览器中有原生的API"),v("code",[e._v("requestIdleCallback")]),e._v("，但是该api存在以下问题")]),e._v(" "),v("ul",[v("li",[e._v("兼容性")]),e._v(" "),v("li",[e._v("触发频率不稳定，影响因素很多。比如当前tab切换后，之前tab注册的时间触发的频率会变得很低。")])]),e._v(" "),v("p",[e._v("所以React实现了"),v("code",[e._v("requestIdleCallback")]),e._v("pollyfill。除了在空闲时触发回调的功能外，还提供了多种调度优先级供任务设置。")]),e._v(" "),v("h3",{attrs:{id:"reconciler-协调器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#reconciler-协调器"}},[e._v("#")]),e._v(" Reconciler（协调器）")]),e._v(" "),v("p",[e._v("16+版本中，"),v("code",[e._v("Reconciler")]),e._v(" 更新工作从递归变成了可中断的循环过程。每次循环都会调用"),v("code",[e._v("shouldYield")]),e._v("获取当前是否有剩余时间。并且"),v("code",[e._v("Reconciler")]),e._v("和"),v("code",[e._v("Renderer")]),e._v("不再是交替工作。当"),v("code",[e._v("Schuduler")]),e._v("把任务交给"),v("code",[e._v("Reconciler")]),e._v("之后，"),v("code",[e._v("Reconciler")]),e._v("会为变化的虚拟DOM打上标记（增/删/更新）")]),e._v(" "),v("p",[e._v("整个过程都在内存中进行。只有当所有组件都完成"),v("code",[e._v("Reconciler")]),e._v("的工作，再会统一交给"),v("code",[e._v("Renderer")]),e._v("进行渲染工作")]),e._v(" "),v("p",[v("code",[e._v("Reconciler")]),e._v(" 和 "),v("code",[e._v("Schuduler")]),e._v(" 被称为 "),v("code",[e._v("render")]),e._v(" 阶段，具体流程如下：")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("beginwork")]),e._v(" 递")]),e._v(" "),v("ul",[v("li",[e._v("从 "),v("code",[e._v("rootFiber")]),e._v(" 开始 "),v("code",[e._v("child")]),e._v("，如果遇到函数组件或者类组件则调用渲染函数生成新的 "),v("code",[e._v("child")]),e._v("(Fiber Array)")]),e._v(" "),v("li",[v("code",[e._v("reconcilerChildren")]),e._v("，对已存在的child与生成的child进行diff，如果是单节点，直接进入更新单节点，如果是数组，则会进入diff逻辑，尽可能复用已有Fiber，创建的effectTag包含更新、删除并且更新 "),v("code",[e._v("父Fiber")]),e._v(" 的tag，如果是新建的话就不需要打tag\n"),v("code",[e._v("diff算法")]),e._v(":\n"),v("ul",[v("li",[v("code",[e._v("oldChild")]),e._v(" 与新渲染产生的child循序遍历，比较tag与key，如果相同则复用，判断props是否需要更新，需要更新则标记 "),v("code",[e._v("update")]),e._v(" 并更新父节点 "),v("code",[e._v("effectTag")]),e._v("，更新"),v("code",[e._v("lastPlaceIndex")])]),e._v(" "),v("li",[e._v("一旦遇到不能复用，则把"),v("code",[e._v("oldChild")]),e._v("创建map，遍历新节点，在map中查找可复用节点,如果没找到则新建 "),v("code",[e._v("Fiber")])]),e._v(" "),v("li",[e._v("遍历map，打上 "),v("code",[e._v("delete")]),e._v(" 标记")])])])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("completework")]),e._v(" 归")]),e._v(" "),v("ul",[v("li",[e._v("处理flag：把 "),v("code",[e._v("Fiber")]),e._v(" 自身的 "),v("code",[e._v("flag")]),e._v(" 以及 "),v("code",[e._v("subtreeFlag")]),e._v(" 冒泡到 "),v("code",[e._v("父Fiber")])]),e._v(" "),v("li",[e._v("处理 "),v("code",[e._v("Fiber")]),e._v(" 的 "),v("code",[e._v("stateNode")]),e._v("，如果没有则需要创建，并且把子孙节点append到当前DOM节点下，存在的话就更新props、事件绑定等")]),e._v(" "),v("li",[e._v("把每个 "),v("code",[e._v("Fiber")]),e._v(" 的 "),v("code",[e._v("Effect")]),e._v(" 添加到 "),v("code",[e._v("父Fiber")]),e._v(" 上组成 "),v("code",[e._v("effectList")]),e._v("，在commit阶段会遍历单向链执行对应操作")])])])]),e._v(" "),v("h3",{attrs:{id:"renderer-渲染器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#renderer-渲染器"}},[e._v("#")]),e._v(" Renderer（渲染器）")]),e._v(" "),v("p",[v("code",[e._v("Renderer")]),e._v("根据"),v("code",[e._v("Reconciler")]),e._v("的标记，同步执行对应的DOM操作\n此阶段也称为"),v("code",[e._v("commit 阶段")]),e._v("，分为三个步骤：")]),e._v(" "),v("h4",{attrs:{id:"before-mutation"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#before-mutation"}},[e._v("#")]),e._v(" before mutation")]),e._v(" "),v("p",[e._v("遍历 "),v("code",[e._v("effectList")]),e._v(" 处理 "),v("code",[e._v("DOM")]),e._v(" 节点 "),v("code",[e._v("渲染/删除")]),e._v(" 后的 "),v("code",[e._v("聚焦/失焦")]),e._v(" 逻辑，调用 "),v("code",[e._v("getSnapShotBeforeUpdate")]),e._v(" 生命周期钩子，调度 "),v("code",[e._v("useEffect")]),e._v(" （使用SchedulerCallback调度）")]),e._v(" "),v("h4",{attrs:{id:"mutation"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mutation"}},[e._v("#")]),e._v(" mutation")]),e._v(" "),v("ul",[v("li",[e._v("更新文本节点的content")]),e._v(" "),v("li",[e._v("更新ref")]),e._v(" "),v("li",[e._v("根据 "),v("code",[e._v("effectTag")]),e._v(" 进行对应处理，包含操作：移动、插入、更新、删除等组合")]),e._v(" "),v("li",[e._v("更新 "),v("code",[e._v("DOM")]),e._v(" props、properties（遍历pendingProps，数据在completeWork阶段完成处理）")]),e._v(" "),v("li",[e._v("如果是 "),v("code",[e._v("FC")]),e._v(" 则需要调用 "),v("code",[e._v("useLayout")]),e._v(" 的销毁函数")]),e._v(" "),v("li",[e._v("完成后再进入 "),v("code",[e._v("layout")]),e._v(" 阶段前需要把current指针切换，因为 "),v("code",[e._v("mutation")]),e._v(" 阶段会调用 "),v("code",[e._v("componentWillUnmount")]),e._v("，此时的 "),v("code",[e._v("DOM")]),e._v(" 还是更新前的")])]),e._v(" "),v("h4",{attrs:{id:"layout"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#layout"}},[e._v("#")]),e._v(" layout")]),e._v(" "),v("p",[e._v("到达这个阶段，已经完成 "),v("code",[e._v("离屏DOM")]),e._v(" 的布局，只是浏览器尚未完成渲染")]),e._v(" "),v("ul",[v("li",[e._v("遍历 "),v("code",[e._v("effectList")]),e._v(" 执行 "),v("code",[e._v("commitLayoutEffcts")]),e._v(" 函数：赋值 "),v("code",[e._v("ref")]),e._v("、调用生命周期钩子和hooks")]),e._v(" "),v("li",[e._v("执行 "),v("code",[e._v("useLayout")]),e._v(" 回调函数，调度 "),v("code",[e._v("useEffect")]),e._v(" 的销毁函数以及回调函数")]),e._v(" "),v("li",[e._v("类组件 "),v("code",[e._v("this.setState")]),e._v(" 的第二个回调函数也会执行")]),e._v(" "),v("li",[e._v("执行的生命周期钩子："),v("code",[e._v("componentDidMount")]),e._v(", "),v("code",[e._v("componentDidUpdate")])])])])}),[],!1,null,null,null);v.default=o.exports}}]);