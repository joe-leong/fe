(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{321:function(v,e,_){"use strict";_.r(e);var a=_(14),t=Object(a.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"vue2-x-专题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2-x-专题"}},[v._v("#")]),v._v(" Vue2.x 专题")]),v._v(" "),e("h2",{attrs:{id:"目录结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#目录结构"}},[v._v("#")]),v._v(" 目录结构")]),v._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[v._v("src\n├── compiler # 编译相关\n├── core     # 核心\n├── platforms# 不同平台入口\n├── server   # 服务端渲染\n├── sfc      # "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("vue文件解析\n└── shared   # 共享代码\n")])])]),e("ul",[e("li",[e("p",[v._v("compiler\n模板生成 ast，ast 优化，ast 生成代码")]),v._v(" "),e("p",[v._v("编译可以在构建时做（webpack，vite，vue-loader 等辅助插件），也可以在运行时做，但是编译是一件耗时的工作，一般都选择构建时做。")])])]),v._v(" "),e("h2",{attrs:{id:"原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[v._v("#")]),v._v(" 原理")]),v._v(" "),e("h3",{attrs:{id:"双向绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双向绑定"}},[v._v("#")]),v._v(" 双向绑定")]),v._v(" "),e("p",[v._v("双向绑定由三个重要部分构成：")]),v._v(" "),e("ul",[e("li",[v._v("数据层（Model）：应用的数据及业务逻辑")]),v._v(" "),e("li",[v._v("视图层（View）：应用的展示效果，各类UI组件")]),v._v(" "),e("li",[v._v("业务逻辑层（ViewModel）：框架封装的核心，它负责将数据与视图关联起来")])]),v._v(" "),e("h4",{attrs:{id:"viewmodel"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#viewmodel"}},[v._v("#")]),v._v(" ViewModel")]),v._v(" "),e("p",[v._v("主要职责就是：")]),v._v(" "),e("ul",[e("li",[v._v("数据变化后更新视图")]),v._v(" "),e("li",[v._v("视图变化后更新数据")])]),v._v(" "),e("p",[v._v("两个重要组成部分：")]),v._v(" "),e("ul",[e("li",[v._v("监听器（Observer）：对所有数据的属性进行监听")]),v._v(" "),e("li",[v._v("解析器（Compiler）：对每个元素节点的指令进行扫描跟解析，根据指令模板替换数据，以及绑定响应的更新函数")])]),v._v(" "),e("h4",{attrs:{id:"实现双向绑定"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#实现双向绑定"}},[v._v("#")]),v._v(" 实现双向绑定")]),v._v(" "),e("ol",[e("li",[e("code",[v._v("new Vue()")]),v._v(" 首先执行初始化，对 "),e("code",[v._v("data")]),v._v(" 执行响应化处理，这个过程发生在 "),e("code",[v._v("Observe")]),v._v(" 中")]),v._v(" "),e("li",[v._v("对模板执行编译，找到其中动态绑定的数据，从 "),e("code",[v._v("data")]),v._v(" 中获取并初始化视图，这个过程发生在 "),e("code",[v._v("Compiler")]),v._v(" 中")]),v._v(" "),e("li",[v._v("定义一个更新函数和 "),e("code",[v._v("Watcher")]),v._v("，将来对应数据变化时 "),e("code",[v._v("Watcher")]),v._v(" 会调用更新函数")]),v._v(" "),e("li",[v._v("由于 "),e("code",[v._v("data")]),v._v(" 的某个 "),e("code",[v._v("key")]),v._v(" 在一个视图中可能出现多次，所以每个 "),e("code",[v._v("key")]),v._v(" 都需要一个管家 "),e("code",[v._v("Dep")]),v._v(" 来管理多个 "),e("code",[v._v("Watcher")])]),v._v(" "),e("li",[v._v("将来 "),e("code",[v._v("data")]),v._v(" 中数据一旦发生变化，会首先找到对应的 "),e("code",[v._v("Dep")]),v._v("，通知所有的 "),e("code",[v._v("Watcher")]),v._v(" 执行更新函数\n🚧")])])])}),[],!1,null,null,null);e.default=t.exports}}]);